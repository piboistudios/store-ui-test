// Generated by Haxe 4.2.0
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var CryptoTool = function() { };
CryptoTool.__name__ = true;
CryptoTool.main = function() {
	var args = process.argv.slice(2);
	var mode = args[0];
	var data = args[1];
	var key = args[2];
	var nonce = args.length > 3 ? args[3] : security_CryptoProvider.getNonce();
	console.log("src/CryptoTool.hx:13:",mode);
	var output;
	switch(mode) {
	case "decrypt":
		var data1 = haxe_crypto_Base64.decode(data);
		console.log("src/CryptoTool.hx:19:",data1);
		output = security_CryptoProvider.decrypt(data1,key,nonce).toString();
		break;
	case "encrypt":
		output = haxe_crypto_Base64.encode(security_CryptoProvider.encrypt(haxe_io_Bytes.ofString(data),key,nonce));
		break;
	default:
		throw haxe_Exception.thrown("invalid command");
	}
	console.log("src/CryptoTool.hx:24:","Output: " + output + ", nonce: " + nonce);
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.now = function() {
	return Date.now();
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.hex = function(n,digits) {
	var s = "";
	while(true) {
		s = "0123456789ABCDEF".charAt(n & 15) + s;
		n >>>= 4;
		if(!(n > 0)) {
			break;
		}
	}
	if(digits != null) {
		while(s.length < digits) s = "0" + s;
	}
	return s;
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,flush: function() {
		js_node_Fs.fsyncSync(this.fd);
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
var _$Sys_FileInput = function(fd) {
	this.fd = fd;
};
_$Sys_FileInput.__name__ = true;
_$Sys_FileInput.__super__ = haxe_io_Input;
_$Sys_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = js_node_buffer_Buffer.alloc(1);
		try {
			js_node_Fs.readSync(this.fd,buf,0,1,null);
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(_g1.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(_g1));
			}
		}
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		try {
			return js_node_Fs.readSync(this.fd,buf,pos,len,null);
		} catch( _g ) {
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(_g1.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(_g1));
			}
		}
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
});
var haxe_Int32 = {};
haxe_Int32.ucompare = function(a,b) {
	if(a < 0) {
		if(b < 0) {
			return ~b - ~a | 0;
		} else {
			return 1;
		}
	}
	if(b < 0) {
		return -1;
	} else {
		return a - b | 0;
	}
};
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
haxe__$Int64__$_$_$Int64.__name__ = true;
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
});
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofHex = function(s) {
	if((s.length & 1) != 0) {
		throw haxe_Exception.thrown("Not a hex string (odd number of digits)");
	}
	var a = [];
	var i = 0;
	var len = s.length >> 1;
	while(i < len) {
		var high = s.charCodeAt(i * 2);
		var low = s.charCodeAt(i * 2 + 1);
		high = (high & 15) + ((high & 64) >> 6) * 9;
		low = (low & 15) + ((low & 64) >> 6) * 9;
		a.push((high << 4 | low) & 255);
		++i;
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var code1 = (c & 31) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var u = (c & 15) << 18 | (b[i++] & 127) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = true;
haxe_crypto_Base64.encode = function(bytes,complement) {
	if(complement == null) {
		complement = true;
	}
	var str = new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(bytes).toString();
	if(complement) {
		switch(bytes.length % 3) {
		case 1:
			str += "==";
			break;
		case 2:
			str += "=";
			break;
		default:
		}
	}
	return str;
};
haxe_crypto_Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
	}
	return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw haxe_Exception.thrown("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
haxe_crypto_BaseCode.__name__ = true;
haxe_crypto_BaseCode.prototype = {
	encodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		var size = b.length * 8 / nbits | 0;
		var out = new haxe_io_Bytes(new ArrayBuffer(size + (b.length * 8 % nbits == 0 ? 0 : 1)));
		var buf = 0;
		var curbits = 0;
		var mask = (1 << nbits) - 1;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < nbits) {
				curbits += 8;
				buf <<= 8;
				buf |= b.b[pin++];
			}
			curbits -= nbits;
			out.b[pout++] = base.b[buf >> curbits & mask];
		}
		if(curbits > 0) {
			out.b[pout++] = base.b[buf << nbits - curbits & mask];
		}
		return out;
	}
	,initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) tbl[_g++] = -1;
		var _g = 0;
		var _g1 = this.base.length;
		while(_g < _g1) {
			var i = _g++;
			tbl[this.base.b[i]] = i;
		}
		this.tbl = tbl;
	}
	,decodeBytes: function(b) {
		var nbits = this.nbits;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.length * nbits >> 3;
		var out = new haxe_io_Bytes(new ArrayBuffer(size));
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.b[pin++]];
				if(i == -1) {
					throw haxe_Exception.thrown("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
};
var haxe_crypto_Salsa20 = function(rounds) {
	if(rounds == null) {
		rounds = 20;
	}
	this.rounds = 20;
	this.state = new Array(16);
	this.sigmas = haxe_crypto_Salsa20.sigmas_array.slice(0);
	this.counter = new haxe__$Int64__$_$_$Int64(0,0);
	this.rounds = rounds;
};
haxe_crypto_Salsa20.__name__ = true;
haxe_crypto_Salsa20.rol32 = function(x,n) {
	return x << n | x >>> 32 - n;
};
haxe_crypto_Salsa20.prototype = {
	init: function(key,nonce) {
		if(nonce == null || nonce.length != 8) {
			throw haxe_Exception.thrown("Nonce must be exactly 8 bytes");
		}
		if(key == null) {
			throw haxe_Exception.thrown("Key must be 16 or 32 bytes");
		}
		if(key.length != 16 && key.length != 32) {
			throw haxe_Exception.thrown("Wrong key size");
		}
		this.setConstant(key);
		this.setNonce(nonce);
		this.setKey(key);
		this.reset();
	}
	,setConstant: function(key) {
		var sigmaOffset = key.length == 16 ? 0 : 4;
		this.state[0] = this.sigmas[sigmaOffset];
		this.state[5] = this.sigmas[sigmaOffset + 1];
		this.state[10] = this.sigmas[sigmaOffset + 2];
		this.state[15] = this.sigmas[sigmaOffset + 3];
	}
	,setKey: function(key) {
		if(key.length == 16) {
			this.state[1] = this.state[11] = this.bytesToInt32(key,0);
			this.state[2] = this.state[12] = this.bytesToInt32(key,4);
			this.state[3] = this.state[13] = this.bytesToInt32(key,8);
			this.state[4] = this.state[14] = this.bytesToInt32(key,12);
		} else {
			this.state[1] = this.bytesToInt32(key,0);
			this.state[11] = this.bytesToInt32(key,16);
			this.state[2] = this.bytesToInt32(key,4);
			this.state[12] = this.bytesToInt32(key,20);
			this.state[3] = this.bytesToInt32(key,8);
			this.state[13] = this.bytesToInt32(key,24);
			this.state[4] = this.bytesToInt32(key,12);
			this.state[14] = this.bytesToInt32(key,28);
		}
	}
	,setNonce: function(nonce) {
		this.state[6] = this.bytesToInt32(nonce,0);
		this.state[7] = this.bytesToInt32(nonce,4);
	}
	,reset: function() {
		this.index = 0;
		this.resetCounter();
		this.generateExpandBlock();
	}
	,resetCounter: function() {
		this.counter = new haxe__$Int64__$_$_$Int64(0,0);
		this.state[9] = 0;
		this.state[8] = 0;
	}
	,updateCounterState: function() {
		this.state[8] = this.counter.low;
		this.state[9] = this.counter.high;
	}
	,increaseCounter: function(num) {
		var a = this.counter;
		var high = a.high + num.high | 0;
		var low = a.low + num.low | 0;
		if(haxe_Int32.ucompare(low,a.low) < 0) {
			++high;
			high = high | 0;
		}
		this.counter = new haxe__$Int64__$_$_$Int64(high,low);
		this.updateCounterState();
	}
	,decreaseCounter: function(num) {
		var a = this.counter;
		var high = a.high - num.high | 0;
		if(haxe_Int32.ucompare(a.low,num.low) < 0) {
			--high;
			high = high | 0;
		}
		this.counter = new haxe__$Int64__$_$_$Int64(high,a.low - num.low | 0);
		this.updateCounterState();
	}
	,getPosition: function() {
		var a = this.counter;
		var b_low = 64;
		var al = a.low & 65535;
		var ah = a.low >>> 16;
		var bl = b_low & 65535;
		var bh = b_low >>> 16;
		var p00 = haxe_Int32._mul(al,bl);
		var p10 = haxe_Int32._mul(ah,bl);
		var p01 = haxe_Int32._mul(al,bh);
		var low = p00;
		var high = (haxe_Int32._mul(ah,bh) + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
		p01 <<= 16;
		low = p00 + p01 | 0;
		if(haxe_Int32.ucompare(low,p01) < 0) {
			++high;
			high = high | 0;
		}
		p10 <<= 16;
		low = low + p10 | 0;
		if(haxe_Int32.ucompare(low,p10) < 0) {
			++high;
			high = high | 0;
		}
		high = high + (haxe_Int32._mul(a.low,0) + haxe_Int32._mul(a.high,b_low) | 0) | 0;
		var a_low = low;
		var x = this.index;
		var high1 = high + (x >> 31) | 0;
		var low = a_low + x | 0;
		if(haxe_Int32.ucompare(low,a_low) < 0) {
			++high1;
			high1 = high1 | 0;
		}
		return new haxe__$Int64__$_$_$Int64(high1,low);
	}
	,seek: function(position) {
		this.reset();
		this.skip(position);
	}
	,skip: function(numBytes) {
		var v = numBytes.high - 0 | 0;
		if(v == 0) {
			v = haxe_Int32.ucompare(numBytes.low,0);
		}
		if((numBytes.high < 0 ? -1 : v) >= 0) {
			var remaining = numBytes;
			var v = numBytes.high - 0 | 0;
			if(v == 0) {
				v = haxe_Int32.ucompare(numBytes.low,64);
			}
			if((numBytes.high < 0 ? -1 : v) >= 0) {
				var count = new haxe__$Int64__$_$_$Int64(numBytes.high >> 6,numBytes.high << 26 | numBytes.low >>> 6);
				this.increaseCounter(count);
				var b_low = 64;
				var al = count.low & 65535;
				var ah = count.low >>> 16;
				var bl = b_low & 65535;
				var bh = b_low >>> 16;
				var p00 = haxe_Int32._mul(al,bl);
				var p10 = haxe_Int32._mul(ah,bl);
				var p01 = haxe_Int32._mul(al,bh);
				var low = p00;
				var high = (haxe_Int32._mul(ah,bh) + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
				p01 <<= 16;
				low = p00 + p01 | 0;
				if(haxe_Int32.ucompare(low,p01) < 0) {
					++high;
					high = high | 0;
				}
				p10 <<= 16;
				low = low + p10 | 0;
				if(haxe_Int32.ucompare(low,p10) < 0) {
					++high;
					high = high | 0;
				}
				high = high + (haxe_Int32._mul(count.low,0) + haxe_Int32._mul(count.high,b_low) | 0) | 0;
				var b_low = low;
				var high1 = numBytes.high - high | 0;
				if(haxe_Int32.ucompare(numBytes.low,b_low) < 0) {
					--high1;
					high1 = high1 | 0;
				}
				remaining = new haxe__$Int64__$_$_$Int64(high1,numBytes.low - b_low | 0);
			}
			var previousIndex = this.index;
			var x = this.index;
			var a_low = x;
			var high = (x >> 31) + remaining.high | 0;
			var low = a_low + remaining.low | 0;
			if(haxe_Int32.ucompare(low,a_low) < 0) {
				++high;
				high = high | 0;
			}
			var low1 = low & 63;
			if((high & 0) != low1 >> 31) {
				throw haxe_Exception.thrown("Overflow");
			}
			this.index = low1;
			if(this.index < previousIndex) {
				this.increaseCounter(new haxe__$Int64__$_$_$Int64(0,1));
			}
		} else {
			var high = ~numBytes.high;
			var low = ~numBytes.low + 1 | 0;
			if(low == 0) {
				++high;
				high = high | 0;
			}
			var remaining = new haxe__$Int64__$_$_$Int64(high,low);
			var v = remaining.high - 0 | 0;
			if(v == 0) {
				v = haxe_Int32.ucompare(remaining.low,64);
			}
			if((remaining.high < 0 ? -1 : v) >= 0) {
				var count = new haxe__$Int64__$_$_$Int64(remaining.high >> 6,remaining.high << 26 | remaining.low >>> 6);
				this.decreaseCounter(count);
				var b_low = 64;
				var al = count.low & 65535;
				var ah = count.low >>> 16;
				var bl = b_low & 65535;
				var bh = b_low >>> 16;
				var p00 = haxe_Int32._mul(al,bl);
				var p10 = haxe_Int32._mul(ah,bl);
				var p01 = haxe_Int32._mul(al,bh);
				var low = p00;
				var high = (haxe_Int32._mul(ah,bh) + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
				p01 <<= 16;
				low = p00 + p01 | 0;
				if(haxe_Int32.ucompare(low,p01) < 0) {
					++high;
					high = high | 0;
				}
				p10 <<= 16;
				low = low + p10 | 0;
				if(haxe_Int32.ucompare(low,p10) < 0) {
					++high;
					high = high | 0;
				}
				high = high + (haxe_Int32._mul(count.low,0) + haxe_Int32._mul(count.high,b_low) | 0) | 0;
				var b_low = low;
				var high1 = remaining.high - high | 0;
				if(haxe_Int32.ucompare(remaining.low,b_low) < 0) {
					--high1;
					high1 = high1 | 0;
				}
				remaining = new haxe__$Int64__$_$_$Int64(high1,remaining.low - b_low | 0);
			}
			var i = new haxe__$Int64__$_$_$Int64(0,0);
			while(true) {
				var v = i.high - remaining.high | 0;
				if(v == 0) {
					v = haxe_Int32.ucompare(i.low,remaining.low);
				}
				if(!((i.high < 0 ? remaining.high < 0 ? v : -1 : remaining.high >= 0 ? v : 1) < 0)) {
					break;
				}
				if(this.index == 0) {
					this.decreaseCounter(new haxe__$Int64__$_$_$Int64(0,1));
				}
				this.index = this.index - 1 & 63;
				i = new haxe__$Int64__$_$_$Int64(i.high,i.low);
				i.low++;
				i.low = i.low | 0;
				if(i.low == 0) {
					i.high++;
					i.high = i.high | 0;
				}
			}
		}
		this.generateExpandBlock();
	}
	,getCounter: function() {
		return this.counter;
	}
	,encrypt: function(data,rounds) {
		if(rounds == null) {
			rounds = 20;
		}
		var output = new haxe_io_Bytes(new ArrayBuffer(data.length));
		var _g = 0;
		var _g1 = data.length;
		while(_g < _g1) {
			var i = _g++;
			output.b[i] = haxe_crypto_Salsa20.expandState.b[this.index] ^ data.b[i];
			this.index = this.index + 1 & 63;
			if(this.index == 0) {
				this.increaseCounter(new haxe__$Int64__$_$_$Int64(0,1));
				this.generateExpandBlock();
			}
		}
		return output;
	}
	,decrypt: function(data,rounds) {
		if(rounds == null) {
			rounds = 20;
		}
		return this.encrypt(data,rounds);
	}
	,generateExpandBlock: function() {
		this.generateBlock(this.state,haxe_crypto_Salsa20.buffer,this.rounds);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[0],haxe_crypto_Salsa20.expandState,0);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[1],haxe_crypto_Salsa20.expandState,4);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[2],haxe_crypto_Salsa20.expandState,8);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[3],haxe_crypto_Salsa20.expandState,12);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[4],haxe_crypto_Salsa20.expandState,16);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[5],haxe_crypto_Salsa20.expandState,20);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[6],haxe_crypto_Salsa20.expandState,24);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[7],haxe_crypto_Salsa20.expandState,28);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[8],haxe_crypto_Salsa20.expandState,32);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[9],haxe_crypto_Salsa20.expandState,36);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[10],haxe_crypto_Salsa20.expandState,40);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[11],haxe_crypto_Salsa20.expandState,44);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[12],haxe_crypto_Salsa20.expandState,48);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[13],haxe_crypto_Salsa20.expandState,52);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[14],haxe_crypto_Salsa20.expandState,56);
		this.int32ToBytes(haxe_crypto_Salsa20.buffer[15],haxe_crypto_Salsa20.expandState,60);
	}
	,generateBlock: function(input,output,rounds,offset) {
		if(offset == null) {
			offset = 0;
		}
		if(rounds == null) {
			rounds = 20;
		}
		if((rounds & 1) != 0) {
			throw haxe_Exception.thrown("Rounds should be a positive, even number");
		}
		if(offset + 16 > output.length || input.length != 16) {
			throw haxe_Exception.thrown("Invalid buffer size");
		}
		var x0 = input[0];
		var x1 = input[1];
		var x2 = input[2];
		var x3 = input[3];
		var x4 = input[4];
		var x5 = input[5];
		var x6 = input[6];
		var x7 = input[7];
		var x8 = input[8];
		var x9 = input[9];
		var x10 = input[10];
		var x11 = input[11];
		var x12 = input[12];
		var x13 = input[13];
		var x14 = input[14];
		var x15 = input[15];
		var h = rounds >> 1;
		var _g = 0;
		while(_g < h) {
			++_g;
			var x = x0 + x12;
			x4 ^= x << 7 | x >>> 25;
			var x16 = x4 + x0;
			x8 ^= x16 << 9 | x16 >>> 23;
			var x17 = x8 + x4;
			x12 ^= x17 << 13 | x17 >>> 19;
			var x18 = x12 + x8;
			x0 ^= x18 << 18 | x18 >>> 14;
			var x19 = x5 + x1;
			x9 ^= x19 << 7 | x19 >>> 25;
			var x20 = x9 + x5;
			x13 ^= x20 << 9 | x20 >>> 23;
			var x21 = x13 + x9;
			x1 ^= x21 << 13 | x21 >>> 19;
			var x22 = x1 + x13;
			x5 ^= x22 << 18 | x22 >>> 14;
			var x23 = x10 + x6;
			x14 ^= x23 << 7 | x23 >>> 25;
			var x24 = x14 + x10;
			x2 ^= x24 << 9 | x24 >>> 23;
			var x25 = x2 + x14;
			x6 ^= x25 << 13 | x25 >>> 19;
			var x26 = x6 + x2;
			x10 ^= x26 << 18 | x26 >>> 14;
			var x27 = x15 + x11;
			x3 ^= x27 << 7 | x27 >>> 25;
			var x28 = x3 + x15;
			x7 ^= x28 << 9 | x28 >>> 23;
			var x29 = x7 + x3;
			x11 ^= x29 << 13 | x29 >>> 19;
			var x30 = x11 + x7;
			x15 ^= x30 << 18 | x30 >>> 14;
			var x31 = x0 + x3;
			x1 ^= x31 << 7 | x31 >>> 25;
			var x32 = x1 + x0;
			x2 ^= x32 << 9 | x32 >>> 23;
			var x33 = x2 + x1;
			x3 ^= x33 << 13 | x33 >>> 19;
			var x34 = x3 + x2;
			x0 ^= x34 << 18 | x34 >>> 14;
			var x35 = x5 + x4;
			x6 ^= x35 << 7 | x35 >>> 25;
			var x36 = x6 + x5;
			x7 ^= x36 << 9 | x36 >>> 23;
			var x37 = x7 + x6;
			x4 ^= x37 << 13 | x37 >>> 19;
			var x38 = x4 + x7;
			x5 ^= x38 << 18 | x38 >>> 14;
			var x39 = x10 + x9;
			x11 ^= x39 << 7 | x39 >>> 25;
			var x40 = x11 + x10;
			x8 ^= x40 << 9 | x40 >>> 23;
			var x41 = x8 + x11;
			x9 ^= x41 << 13 | x41 >>> 19;
			var x42 = x9 + x8;
			x10 ^= x42 << 18 | x42 >>> 14;
			var x43 = x15 + x14;
			x12 ^= x43 << 7 | x43 >>> 25;
			var x44 = x12 + x15;
			x13 ^= x44 << 9 | x44 >>> 23;
			var x45 = x13 + x12;
			x14 ^= x45 << 13 | x45 >>> 19;
			var x46 = x14 + x13;
			x15 ^= x46 << 18 | x46 >>> 14;
		}
		output[offset] = x0 + input[0];
		output[offset + 1] = x1 + input[1];
		output[offset + 2] = x2 + input[2];
		output[offset + 3] = x3 + input[3];
		output[offset + 4] = x4 + input[4];
		output[offset + 5] = x5 + input[5];
		output[offset + 6] = x6 + input[6];
		output[offset + 7] = x7 + input[7];
		output[offset + 8] = x8 + input[8];
		output[offset + 9] = x9 + input[9];
		output[offset + 10] = x10 + input[10];
		output[offset + 11] = x11 + input[11];
		output[offset + 12] = x12 + input[12];
		output[offset + 13] = x13 + input[13];
		output[offset + 14] = x14 + input[14];
		output[offset + 15] = x15 + input[15];
	}
	,int32ToBytes: function(n,bs,off) {
		bs.b[off] = n;
		bs.b[++off] = n >>> 8;
		bs.b[++off] = n >>> 16;
		bs.b[++off] = n >>> 24;
	}
	,bytesToInt32: function(bs,off) {
		var n = bs.b[off];
		n |= bs.b[++off] << 8;
		n |= bs.b[++off] << 16;
		n |= bs.b[++off] << 24;
		return n;
	}
};
var haxe_crypto_ChaCha = function(rounds) {
	haxe_crypto_Salsa20.call(this,rounds);
};
haxe_crypto_ChaCha.__name__ = true;
haxe_crypto_ChaCha.rol32 = function(x,n) {
	return x << n | x >>> 32 - n;
};
haxe_crypto_ChaCha.__super__ = haxe_crypto_Salsa20;
haxe_crypto_ChaCha.prototype = $extend(haxe_crypto_Salsa20.prototype,{
	setConstant: function(key) {
		var sigmaOffset = key.length == 16 ? 0 : 4;
		this.state[0] = this.sigmas[sigmaOffset];
		this.state[1] = this.sigmas[sigmaOffset + 1];
		this.state[2] = this.sigmas[sigmaOffset + 2];
		this.state[3] = this.sigmas[sigmaOffset + 3];
	}
	,resetCounter: function() {
		this.counter = new haxe__$Int64__$_$_$Int64(0,0);
		this.state[13] = 0;
		this.state[12] = 0;
	}
	,updateCounterState: function() {
		this.state[12] = this.counter.low;
		this.state[13] = this.counter.high;
	}
	,setKey: function(key) {
		if(key.length == 16) {
			this.state[4] = this.state[8] = this.bytesToInt32(key,0);
			this.state[5] = this.state[9] = this.bytesToInt32(key,4);
			this.state[6] = this.state[10] = this.bytesToInt32(key,8);
			this.state[7] = this.state[11] = this.bytesToInt32(key,12);
		} else {
			this.state[4] = this.bytesToInt32(key,0);
			this.state[8] = this.bytesToInt32(key,16);
			this.state[5] = this.bytesToInt32(key,4);
			this.state[9] = this.bytesToInt32(key,20);
			this.state[6] = this.bytesToInt32(key,8);
			this.state[10] = this.bytesToInt32(key,24);
			this.state[7] = this.bytesToInt32(key,12);
			this.state[11] = this.bytesToInt32(key,28);
		}
	}
	,setNonce: function(nonce) {
		this.state[14] = this.bytesToInt32(nonce,0);
		this.state[15] = this.bytesToInt32(nonce,4);
	}
	,generateBlock: function(input,output,rounds,offset) {
		if(offset == null) {
			offset = 0;
		}
		if(rounds == null) {
			rounds = 20;
		}
		if((rounds & 1) != 0) {
			throw haxe_Exception.thrown("Rounds should be a positive, even number");
		}
		if(output.length != 16 || input.length != 16) {
			throw haxe_Exception.thrown("Invalid buffer size");
		}
		var x0 = input[0];
		var x1 = input[1];
		var x2 = input[2];
		var x3 = input[3];
		var x4 = input[4];
		var x5 = input[5];
		var x6 = input[6];
		var x7 = input[7];
		var x8 = input[8];
		var x9 = input[9];
		var x10 = input[10];
		var x11 = input[11];
		var x12 = input[12];
		var x13 = input[13];
		var x14 = input[14];
		var x15 = input[15];
		var h = rounds >> 1;
		var _g = 0;
		while(_g < h) {
			++_g;
			x0 += x4;
			var x = x12 ^ x0;
			x12 = x << 16 | x >>> 16;
			x8 += x12;
			var x16 = x4 ^ x8;
			x4 = x16 << 12 | x16 >>> 20;
			x0 += x4;
			var x17 = x12 ^ x0;
			x12 = x17 << 8 | x17 >>> 24;
			x8 += x12;
			var x18 = x4 ^ x8;
			x4 = x18 << 7 | x18 >>> 25;
			x1 += x5;
			var x19 = x13 ^ x1;
			x13 = x19 << 16 | x19 >>> 16;
			x9 += x13;
			var x20 = x5 ^ x9;
			x5 = x20 << 12 | x20 >>> 20;
			x1 += x5;
			var x21 = x13 ^ x1;
			x13 = x21 << 8 | x21 >>> 24;
			x9 += x13;
			var x22 = x5 ^ x9;
			x5 = x22 << 7 | x22 >>> 25;
			x2 += x6;
			var x23 = x14 ^ x2;
			x14 = x23 << 16 | x23 >>> 16;
			x10 += x14;
			var x24 = x6 ^ x10;
			x6 = x24 << 12 | x24 >>> 20;
			x2 += x6;
			var x25 = x14 ^ x2;
			x14 = x25 << 8 | x25 >>> 24;
			x10 += x14;
			var x26 = x6 ^ x10;
			x6 = x26 << 7 | x26 >>> 25;
			x3 += x7;
			var x27 = x15 ^ x3;
			x15 = x27 << 16 | x27 >>> 16;
			x11 += x15;
			var x28 = x7 ^ x11;
			x7 = x28 << 12 | x28 >>> 20;
			x3 += x7;
			var x29 = x15 ^ x3;
			x15 = x29 << 8 | x29 >>> 24;
			x11 += x15;
			var x30 = x7 ^ x11;
			x7 = x30 << 7 | x30 >>> 25;
			x0 += x5;
			var x31 = x15 ^ x0;
			x15 = x31 << 16 | x31 >>> 16;
			x10 += x15;
			var x32 = x5 ^ x10;
			x5 = x32 << 12 | x32 >>> 20;
			x0 += x5;
			var x33 = x15 ^ x0;
			x15 = x33 << 8 | x33 >>> 24;
			x10 += x15;
			var x34 = x5 ^ x10;
			x5 = x34 << 7 | x34 >>> 25;
			x1 += x6;
			var x35 = x12 ^ x1;
			x12 = x35 << 16 | x35 >>> 16;
			x11 += x12;
			var x36 = x6 ^ x11;
			x6 = x36 << 12 | x36 >>> 20;
			x1 += x6;
			var x37 = x12 ^ x1;
			x12 = x37 << 8 | x37 >>> 24;
			x11 += x12;
			var x38 = x6 ^ x11;
			x6 = x38 << 7 | x38 >>> 25;
			x2 += x7;
			var x39 = x13 ^ x2;
			x13 = x39 << 16 | x39 >>> 16;
			x8 += x13;
			var x40 = x7 ^ x8;
			x7 = x40 << 12 | x40 >>> 20;
			x2 += x7;
			var x41 = x13 ^ x2;
			x13 = x41 << 8 | x41 >>> 24;
			x8 += x13;
			var x42 = x7 ^ x8;
			x7 = x42 << 7 | x42 >>> 25;
			x3 += x4;
			var x43 = x14 ^ x3;
			x14 = x43 << 16 | x43 >>> 16;
			x9 += x14;
			var x44 = x4 ^ x9;
			x4 = x44 << 12 | x44 >>> 20;
			x3 += x4;
			var x45 = x14 ^ x3;
			x14 = x45 << 8 | x45 >>> 24;
			x9 += x14;
			var x46 = x4 ^ x9;
			x4 = x46 << 7 | x46 >>> 25;
		}
		output[0] = x0 + input[0];
		output[1] = x1 + input[1];
		output[2] = x2 + input[2];
		output[3] = x3 + input[3];
		output[4] = x4 + input[4];
		output[5] = x5 + input[5];
		output[6] = x6 + input[6];
		output[7] = x7 + input[7];
		output[8] = x8 + input[8];
		output[9] = x9 + input[9];
		output[10] = x10 + input[10];
		output[11] = x11 + input[11];
		output[12] = x12 + input[12];
		output[13] = x13 + input[13];
		output[14] = x14 + input[14];
		output[15] = x15 + input[15];
	}
});
var haxe_crypto_Sha256 = function() {
};
haxe_crypto_Sha256.__name__ = true;
haxe_crypto_Sha256.encode = function(s,encoding) {
	var sh = new haxe_crypto_Sha256();
	var data = haxe_io_Bytes.ofString(s,encoding);
	var nblk = data.length * 8;
	return sh.hex(sh.doEncode(haxe_crypto_Sha256.str2blks(data),nblk));
};
haxe_crypto_Sha256.make = function(b) {
	var h = new haxe_crypto_Sha256().doEncode(haxe_crypto_Sha256.bytes2blks(b),b.length * 8);
	var out = new haxe_io_Bytes(new ArrayBuffer(32));
	var p = 0;
	var _g = 0;
	while(_g < 8) {
		var i = _g++;
		out.b[p++] = h[i] >>> 24;
		out.b[p++] = h[i] >> 16 & 255;
		out.b[p++] = h[i] >> 8 & 255;
		out.b[p++] = h[i] & 255;
	}
	return out;
};
haxe_crypto_Sha256.str2blks = function(data) {
	var nblk = data.length;
	data = haxe_crypto_padding_BitPadding.pad(data,8);
	var blksLenght = data.length >> 2;
	blksLenght += 16 - blksLenght % 16;
	var blks = new Array(blksLenght);
	var i = 0;
	var pos = 0;
	while(i < data.length) {
		blks[pos] = haxe_crypto_Sha256.bytesToInt(data,i);
		i += 4;
		++pos;
	}
	var padding = 16 - pos % 16;
	var _g = 0;
	while(_g < padding) {
		++_g;
		blks[pos] = 0;
		++pos;
	}
	blks[blks.length - 1] = nblk * 8;
	return blks;
};
haxe_crypto_Sha256.bytesToInt = function(bs,off) {
	var n = bs.b[off] << 24;
	n |= bs.b[++off] << 16;
	n |= bs.b[++off] << 8;
	n |= bs.b[++off];
	return n;
};
haxe_crypto_Sha256.bytes2blks = function(b) {
	var nblk = (b.length + 8 >> 6) + 1;
	var blks = new Array(nblk * 16);
	var _g = 0;
	var _g1 = nblk * 16;
	while(_g < _g1) blks[_g++] = 0;
	var _g = 0;
	var _g1 = b.length;
	while(_g < _g1) {
		var i = _g++;
		blks[i >> 2] |= b.b[i] << 24 - ((i & 3) << 3);
	}
	var i = b.length;
	blks[i >> 2] |= 128 << 24 - ((i & 3) << 3);
	blks[nblk * 16 - 1] = b.length * 8;
	return blks;
};
haxe_crypto_Sha256.prototype = {
	doEncode: function(m,l) {
		var K = [1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998].slice(0);
		var HASH = [1779033703,-1150833019,1013904242,-1521486534,1359893119,-1694144372,528734635,1541459225].slice(0);
		var W = new Array(65);
		W[64] = 0;
		var a;
		var b;
		var c;
		var d;
		var e;
		var f;
		var g;
		var h;
		var T1;
		var T2;
		m[l >> 5] |= 128 << 24 - l % 32;
		m[(l + 64 >> 9 << 4) + 15] = l;
		var i = 0;
		while(i < m.length) {
			a = HASH[0];
			b = HASH[1];
			c = HASH[2];
			d = HASH[3];
			e = HASH[4];
			f = HASH[5];
			g = HASH[6];
			h = HASH[7];
			var _g = 0;
			while(_g < 64) {
				var j = _g++;
				if(j < 16) {
					W[j] = m[j + i];
				} else {
					var x = W[j - 2];
					var x1 = (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
					var y = W[j - 7];
					var lsw = (x1 & 65535) + (y & 65535);
					var x2 = (x1 >> 16) + (y >> 16) + (lsw >> 16) << 16 | lsw & 65535;
					var x3 = W[j - 15];
					var y1 = (x3 >>> 7 | x3 << 25) ^ (x3 >>> 18 | x3 << 14) ^ x3 >>> 3;
					var lsw1 = (x2 & 65535) + (y1 & 65535);
					var x4 = (x2 >> 16) + (y1 >> 16) + (lsw1 >> 16) << 16 | lsw1 & 65535;
					var y2 = W[j - 16];
					var lsw2 = (x4 & 65535) + (y2 & 65535);
					W[j] = (x4 >> 16) + (y2 >> 16) + (lsw2 >> 16) << 16 | lsw2 & 65535;
				}
				var y3 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
				var lsw3 = (h & 65535) + (y3 & 65535);
				var x5 = (h >> 16) + (y3 >> 16) + (lsw3 >> 16) << 16 | lsw3 & 65535;
				var y4 = e & f ^ ~e & g;
				var lsw4 = (x5 & 65535) + (y4 & 65535);
				var x6 = (x5 >> 16) + (y4 >> 16) + (lsw4 >> 16) << 16 | lsw4 & 65535;
				var y5 = K[j];
				var lsw5 = (x6 & 65535) + (y5 & 65535);
				var x7 = (x6 >> 16) + (y5 >> 16) + (lsw5 >> 16) << 16 | lsw5 & 65535;
				var y6 = W[j];
				var lsw6 = (x7 & 65535) + (y6 & 65535);
				T1 = (x7 >> 16) + (y6 >> 16) + (lsw6 >> 16) << 16 | lsw6 & 65535;
				var x8 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
				var y7 = a & b ^ a & c ^ b & c;
				var lsw7 = (x8 & 65535) + (y7 & 65535);
				T2 = (x8 >> 16) + (y7 >> 16) + (lsw7 >> 16) << 16 | lsw7 & 65535;
				h = g;
				g = f;
				f = e;
				var lsw8 = (d & 65535) + (T1 & 65535);
				e = (d >> 16) + (T1 >> 16) + (lsw8 >> 16) << 16 | lsw8 & 65535;
				d = c;
				c = b;
				b = a;
				var lsw9 = (T1 & 65535) + (T2 & 65535);
				a = (T1 >> 16) + (T2 >> 16) + (lsw9 >> 16) << 16 | lsw9 & 65535;
			}
			var y8 = HASH[0];
			var lsw10 = (a & 65535) + (y8 & 65535);
			HASH[0] = (a >> 16) + (y8 >> 16) + (lsw10 >> 16) << 16 | lsw10 & 65535;
			var y9 = HASH[1];
			var lsw11 = (b & 65535) + (y9 & 65535);
			HASH[1] = (b >> 16) + (y9 >> 16) + (lsw11 >> 16) << 16 | lsw11 & 65535;
			var y10 = HASH[2];
			var lsw12 = (c & 65535) + (y10 & 65535);
			HASH[2] = (c >> 16) + (y10 >> 16) + (lsw12 >> 16) << 16 | lsw12 & 65535;
			var y11 = HASH[3];
			var lsw13 = (d & 65535) + (y11 & 65535);
			HASH[3] = (d >> 16) + (y11 >> 16) + (lsw13 >> 16) << 16 | lsw13 & 65535;
			var y12 = HASH[4];
			var lsw14 = (e & 65535) + (y12 & 65535);
			HASH[4] = (e >> 16) + (y12 >> 16) + (lsw14 >> 16) << 16 | lsw14 & 65535;
			var y13 = HASH[5];
			var lsw15 = (f & 65535) + (y13 & 65535);
			HASH[5] = (f >> 16) + (y13 >> 16) + (lsw15 >> 16) << 16 | lsw15 & 65535;
			var y14 = HASH[6];
			var lsw16 = (g & 65535) + (y14 & 65535);
			HASH[6] = (g >> 16) + (y14 >> 16) + (lsw16 >> 16) << 16 | lsw16 & 65535;
			var y15 = HASH[7];
			var lsw17 = (h & 65535) + (y15 & 65535);
			HASH[7] = (h >> 16) + (y15 >> 16) + (lsw17 >> 16) << 16 | lsw17 & 65535;
			i += 16;
		}
		return HASH;
	}
	,hex: function(a) {
		var str = "";
		var _g = 0;
		while(_g < a.length) str += StringTools.hex(a[_g++],8);
		return str.toLowerCase();
	}
};
var haxe_crypto_padding_BitPadding = function() { };
haxe_crypto_padding_BitPadding.__name__ = true;
haxe_crypto_padding_BitPadding.pad = function(ciphertext,blockSize) {
	var buffer = new haxe_io_BytesBuffer();
	buffer.addBytes(ciphertext,0,ciphertext.length);
	buffer.addByte(128);
	var padding = blockSize - ciphertext.length % blockSize - 1;
	var _g = 0;
	while(_g < padding) {
		++_g;
		buffer.addByte(0);
	}
	return buffer.getBytes();
};
haxe_crypto_padding_BitPadding.unpad = function(encrypt) {
	var padding = 0;
	var pos = encrypt.length - 1;
	while(padding != 128 && pos > -1) {
		padding = encrypt.b[pos];
		--pos;
	}
	return encrypt.sub(0,pos + 1);
};
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		this.u8.set(new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len),this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
};
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = true;
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
var js_node_Fs = require("fs");
var js_node_KeyValue = {};
js_node_KeyValue.get_key = function(this1) {
	return this1[0];
};
js_node_KeyValue.get_value = function(this1) {
	return this1[1];
};
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_node_stream_WritableNewOptionsAdapter = {};
js_node_stream_WritableNewOptionsAdapter.from = function(options) {
	if(!Object.prototype.hasOwnProperty.call(options,"final")) {
		Object.defineProperty(options,"final",{ get : function() {
			return options.final_;
		}});
	}
	return options;
};
var js_node_url_URLSearchParamsEntry = {};
js_node_url_URLSearchParamsEntry._new = function(name,value) {
	return [name,value];
};
js_node_url_URLSearchParamsEntry.get_name = function(this1) {
	return this1[0];
};
js_node_url_URLSearchParamsEntry.get_value = function(this1) {
	return this1[1];
};
var security_CryptoProvider = function() { };
security_CryptoProvider.__name__ = true;
security_CryptoProvider.mkChaCha = function(key,nonce) {
	var key1 = haxe_crypto_Sha256.make(haxe_io_Bytes.ofString(key));
	nonce = HxOverrides.substr(nonce,0,16);
	console.log("src/security/CryptoProvider.hx:12:",nonce.length);
	var nonce1 = haxe_io_Bytes.ofHex(nonce);
	var chaCha = new haxe_crypto_ChaCha();
	chaCha.init(key1,nonce1);
	return chaCha;
};
security_CryptoProvider.getNonce = function() {
	return StringTools.lpad(Std.string(Std.random(100000000)),"0",8);
};
security_CryptoProvider.encrypt = function(data,key,nonce) {
	return security_CryptoProvider.mkChaCha(key,nonce).encrypt(data);
};
security_CryptoProvider.decrypt = function(data,key,nonce) {
	return security_CryptoProvider.mkChaCha(key,nonce).decrypt(data);
};
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
haxe_Int32._mul = Math.imul != null ? Math.imul : function(a,b) {
	return a * (b & 65535) + (a * (b >>> 16) << 16 | 0) | 0;
};
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxe_crypto_Salsa20.sigmas_array = [1634760805,824206446,2036477238,1797285236,1634760805,857760878,2036477234,1797285236];
haxe_crypto_Salsa20.buffer = new Array(16);
haxe_crypto_Salsa20.expandState = new haxe_io_Bytes(new ArrayBuffer(64));
CryptoTool.main();
})({});
